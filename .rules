# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

# Zed Code Editor

Zed is a high-performance, multiplayer code editor built with Rust. It uses GPUI, a custom GPU-accelerated UI framework, and supports collaborative editing via CRDTs, remote development over SSH, and a WebAssembly-based extension system.

# Building and Testing

## Building Zed

Debug build:
```sh
cargo run
```

Release build:
```sh
cargo run --release
```

On Linux, you can also run the CLI crate directly:
```sh
cargo run -p cli
```

## Running Tests

All tests:
```sh
cargo test --workspace
```

Single test:
```sh
cargo test --package <crate_name> <test_name>
```

Specific crate tests:
```sh
cargo test -p <crate_name>
```

For systems that hit file descriptor limits, use cargo-nextest:
```sh
cargo install cargo-nextest --locked
cargo nextest run --workspace --no-fail-fast
```

## Linting

Use the custom clippy script instead of `cargo clippy`:
```sh
./script/clippy
```

# Codebase Architecture

## Key Crates

**Core Infrastructure:**
- `gpui`: GPU-accelerated UI framework providing immediate-mode UI, entity-based state management, flexbox layout, and cross-platform windowing
- `zed`: Main application crate that assembles all components and manages application lifecycle
- `workspace`: Top-level container for editing sessions, manages panes, docks, panels, and coordinates collaboration
- `project`: Semantics-aware entity managing worktrees, LSP servers, tasks, and git operations. Can be local or remote.
- `editor`: Core text editing component with rendering, selections, syntax highlighting, diagnostics, and vim mode

**Text Foundation:**
- `text`: CRDT-based text buffer supporting collaborative editing with operational transformation
- `rope`: High-performance rope data structure for efficient text operations
- `sum_tree`: B-tree variant optimized for dimensional queries, foundation for text buffers

**Language Support:**
- `language`: Language infrastructure for Tree-sitter syntax highlighting, outline parsing, indentation
- `lsp`: LSP client managing language server communication and request routing
- `languages`: Built-in language definitions (more can be added via extensions)

**Extension System:**
- `extension`: Core extension infrastructure and API
- `extension_host`: Hosts WASM extensions using Wasmtime with sandboxed execution
- `extension_api`: Public API exposed to extensions via WIT bindings

**Remote Development:**
- `remote`: Client-side remote development, manages SSH connections
- `remote_server`: Headless daemon on remote machines providing project access over RPC
- `rpc`: Bidirectional RPC using Protocol Buffers
- `proto`: Protocol Buffer definitions for all RPC messages

**Collaboration:**
- `collab`: Server-side collaboration infrastructure (AGPL-licensed)
- `collab_ui`: UI components for channels, calls, and shared projects
- `client`: Client connection to Zed servers for auth and collaboration
- `call`: Voice/video calling via LiveKit
- `channel`: Channels system for team organization

**Other Important Crates:**
- `settings`: Cascading configuration with JSON schema validation and live reloading
- `theme`: Theme system for color schemes and UI customization
- `ui`: Reusable UI components built on GPUI
- `task`: Task system for builds, tests, and custom commands
- `terminal`: Terminal emulator based on Alacritty
- `search`: Project-wide search using ripgrep
- `vim`: Vim mode implementation
- `fs`: Abstract file system with real and fake implementations for testing
- `worktree`: File tree managing file watching and git status
- `git`: Git integration via libgit2

## Architectural Patterns

### Entity Hierarchy
```
Workspace (window-level container)
├── Panes (tab groups with splits)
│   ├── Editor (items)
│   ├── Terminal
│   └── Other items
├── Docks (left/right/bottom panels)
│   ├── Project Panel
│   ├── Outline Panel
│   └── Other panels
└── Project (manages worktrees and LSP)
    ├── Worktrees (file trees)
    ├── LSP Servers
    ├── Task definitions
    └── Git repositories
```

### CRDT Collaborative Editing
- Text buffers use Conflict-free Replicated Data Types for real-time collaboration
- Each replica has a unique `ReplicaId` with Lamport clock timestamps
- Operations can be applied in any order and converge to the same state
- Anchors track positions across edits using insertion fragments

### Extension System
- Extensions compiled to WASM components, sandboxed in Wasmtime
- Capability-based security controls access
- Can provide: languages, LSP servers, themes, slash commands, debuggers
- Installed in `~/.config/zed/extensions/`
- Hot reloading supported for development

### Remote Development
- Client runs full UI, server runs headlessly on remote machine via SSH
- RPC synchronizes file system, LSP, tasks, and terminal
- Source code stays remote, only diffs transferred
- Server binary auto-downloads or uploads over SSH

### LSP Integration
- `LspStore` manages all language server lifecycle
- Multiple LSP servers per worktree supported
- Capabilities queried and cached
- Diagnostics aggregated across servers
- Extensions can provide custom LSP implementations

# Rust coding guidelines

* Prioritize code correctness and clarity. Speed and efficiency are secondary priorities unless otherwise specified.
* Do not write organizational or comments that summarize the code. Comments should only be written in order to explain "why" the code is written in some way in the case there is a reason that is tricky / non-obvious.
* Prefer implementing functionality in existing files unless it is a new logical component. Avoid creating many small files.
* Avoid using functions that panic like `unwrap()`, instead use mechanisms like `?` to propagate errors.
* Be careful with operations like indexing which may panic if the indexes are out of bounds.
* Never silently discard errors with `let _ =` on fallible operations. Always handle errors appropriately:
  - Propagate errors with `?` when the calling function should handle them
  - Use `.log_err()` or similar when you need to ignore errors but want visibility
  - Use explicit error handling with `match` or `if let Err(...)` when you need custom logic
  - Example: avoid `let _ = client.request(...).await?;` - use `client.request(...).await?;` instead
* When implementing async operations that may fail, ensure errors propagate to the UI layer so users get meaningful feedback.
* Never create files with `mod.rs` paths - prefer `src/some_module.rs` instead of `src/some_module/mod.rs`.
* When creating new crates, prefer specifying the library root path in `Cargo.toml` using `[lib] path = "...rs"` instead of the default `lib.rs`, to maintain consistent and descriptive naming (e.g., `gpui.rs` or `main.rs`).
* Avoid creative additions unless explicitly requested
* Use full words for variable names (no abbreviations like "q" for "queue")
* Use variable shadowing to scope clones in async contexts for clarity, minimizing the lifetime of borrowed references.
  Example:
  ```rust
  executor.spawn({
      let task_ran = task_ran.clone();
      async move {
          *task_ran.borrow_mut() = true;
      }
  });
  ```

# GPUI

GPUI is a UI framework which also provides primitives for state and concurrency management.

## Context

Context types allow interaction with global state, windows, entities, and system services. They are typically passed to functions as the argument named `cx`. When a function takes callbacks they come after the `cx` parameter.

* `App` is the root context type, providing access to global state and read and update of entities.
* `Context<T>` is provided when updating an `Entity<T>`. This context dereferences into `App`, so functions which take `&App` can also take `&Context<T>`.
* `AsyncApp` and `AsyncWindowContext` are provided by `cx.spawn` and `cx.spawn_in`. These can be held across await points.

## `Window`

`Window` provides access to the state of an application window. It is passed to functions as an argument named `window` and comes before `cx` when present. It is used for managing focus, dispatching actions, directly drawing, getting user input state, etc.

## Entities

An `Entity<T>` is a handle to state of type `T`. With `thing: Entity<T>`:

* `thing.entity_id()` returns `EntityId`
* `thing.downgrade()` returns `WeakEntity<T>`
* `thing.read(cx: &App)` returns `&T`.
* `thing.read_with(cx, |thing: &T, cx: &App| ...)` returns the closure's return value.
* `thing.update(cx, |thing: &mut T, cx: &mut Context<T>| ...)` allows the closure to mutate the state, and provides a `Context<T>` for interacting with the entity. It returns the closure's return value.
* `thing.update_in(cx, |thing: &mut T, window: &mut Window, cx: &mut Context<T>| ...)` takes a `AsyncWindowContext` or `VisualTestContext`. It's the same as `update` while also providing the `Window`.

Within the closures, the inner `cx` provided to the closure must be used instead of the outer `cx` to avoid issues with multiple borrows.

Trying to update an entity while it's already being updated must be avoided as this will cause a panic.

When  `read_with`, `update`, or `update_in` are used with an async context, the closure's return value is wrapped in an `anyhow::Result`.

`WeakEntity<T>` is a weak handle. It has `read_with`, `update`, and `update_in` methods that work the same, but always return an `anyhow::Result` so that they can fail if the entity no longer exists. This can be useful to avoid memory leaks - if entities have mutually recursive handles to each other they will never be dropped.

## Concurrency

All use of entities and UI rendering occurs on a single foreground thread.

`cx.spawn(async move |cx| ...)` runs an async closure on the foreground thread. Within the closure, `cx` is an async context like `AsyncApp` or `AsyncWindowContext`.

When the outer cx is a `Context<T>`, the use of `spawn` instead looks like `cx.spawn(async move |handle, cx| ...)`, where `handle: WeakEntity<T>`.

To do work on other threads, `cx.background_spawn(async move { ... })` is used. Often this background task is awaited on by a foreground task which uses the results to update state.

Both `cx.spawn` and `cx.background_spawn` return a `Task<R>`, which is a future that can be awaited upon. If this task is dropped, then its work is cancelled. To prevent this one of the following must be done:

* Awaiting the task in some other async context.
* Detaching the task via `task.detach()` or `task.detach_and_log_err(cx)`, allowing it to run indefinitely.
* Storing the task in a field, if the work should be halted when the struct is dropped.

A task which doesn't do anything but provide a value can be created with `Task::ready(value)`.

## Elements

The `Render` trait is used to render some state into an element tree that is laid out using flexbox layout. An `Entity<T>` where `T` implements `Render` is sometimes called a "view".

Example:

```
struct TextWithBorder(SharedString);

impl Render for TextWithBorder {
    fn render(&mut self, _window: &mut Window, _cx: &mut Context<Self>) -> impl IntoElement {
        div().border_1().child(self.0.clone())
    }
}
```

Since `impl IntoElement for SharedString` exists, it can be used as an argument to `child`. `SharedString` is used to avoid copying strings, and is either an `&'static str` or `Arc<str>`.

UI components that are constructed just to be turned into elements can instead implement the `RenderOnce` trait, which is similar to `Render`, but its `render` method takes ownership of `self`. Types that implement this trait can use `#[derive(IntoElement)]` to use them directly as children.

The style methods on elements are similar to those used by Tailwind CSS.

If some attributes or children of an element tree are conditional, `.when(condition, |this| ...)` can be used to run the closure only when `condition` is true. Similarly, `.when_some(option, |this, value| ...)` runs the closure when the `Option` has a value.

## Input events

Input event handlers can be registered on an element via methods like `.on_click(|event, window, cx: &mut App| ...)`.

Often event handlers will want to update the entity that's in the current `Context<T>`. The `cx.listener` method provides this - its use looks like `.on_click(cx.listener(|this: &mut T, event, window, cx: &mut Context<T>| ...)`.

## Actions

Actions are dispatched via user keyboard interaction or in code via `window.dispatch_action(SomeAction.boxed_clone(), cx)` or `focus_handle.dispatch_action(&SomeAction, window, cx)`.

Actions with no data defined with the `actions!(some_namespace, [SomeAction, AnotherAction])` macro call. Otherwise the `Action` derive macro is used. Doc comments on actions are displayed to the user.

Action handlers can be registered on an element via the event handler `.on_action(|action, window, cx| ...)`. Like other event handlers, this is often used with `cx.listener`.

## Notify

When a view's state has changed in a way that may affect its rendering, it should call `cx.notify()`. This will cause the view to be rerendered. It will also cause any observe callbacks registered for the entity with `cx.observe` to be called.

## Entity events

While updating an entity (`cx: Context<T>`), it can emit an event using `cx.emit(event)`. Entities register which events they can emit by declaring `impl EventEmittor<EventType> for EntityType {}`.

Other entities can then register a callback to handle these events by doing `cx.subscribe(other_entity, |this, other_entity, event, cx| ...)`. This will return a `Subscription` which deregisters the callback when dropped.  Typically `cx.subscribe` happens when creating a new entity and the subscriptions are stored in a `_subscriptions: Vec<Subscription>` field.

## Recent API changes

GPUI has had some changes to its APIs. Always write code using the new APIs:

* `spawn` methods now take async closures (`AsyncFn`), and so should be called like `cx.spawn(async move |cx| ...)`.
* Use `Entity<T>`. This replaces `Model<T>` and `View<T>` which no longer exist and should NEVER be used.
* Use `App` references. This replaces `AppContext` which no longer exists and should NEVER be used.
* Use `Context<T>` references. This replaces `ModelContext<T>` which no longer exists and should NEVER be used.
* `Window` is now passed around explicitly. The new interface adds a `Window` reference parameter to some methods, and adds some new "*_in" methods for plumbing `Window`. The old types `WindowContext` and `ViewContext<T>` should NEVER be used.


## General guidelines

- Use `./script/clippy` instead of `cargo clippy`
