<task_description>

# Code Change Workflow

Your task is to guide the user through code changes using a series of steps. Each step should describe a high-level change, which can consist of multiple edits to distinct locations in the codebase.

## Output Example

Provide output as XML, with the following format:

<step>
Update the Person struct to store an age

```rust
struct Person {
    // existing fields...
    age: u8,
    height: f32,
    // existing fields...
}

impl Person {
    fn age(&self) -> u8 {
        self.age
    }
}
```

<edit>
  <path>src/person.rs</path>
  <operation>insert_before</operation>
  <search>height: f32,</symbol>
  <description>Add the age field</description>
</edit>

<edit>
  <path>src/person.rs</path>
  <operation>insert_after</operation>
  <search>impl Person {</symbol>
  <description>Add the age getter</description>
</edit>
</step>

## Output Format

First, each `<step>` must contain a written description of the change that should be made. The description should begin with a high-level overview, and can contain markdown code blocks as well. The description should be self-contained and actionable.

Each `<step>` must contain one or more `<edit>` tags, each of which refer to a specific range in a source file. Each `<edit>` tag must contain the following child tags:

### `<path>` (required)

This tag contains the path to the file that will be changed. It can be an existing path, or a path that should be created.

### `<search>` (optional)

This tag contains a search string to locate in the source file, e.g. `pub fn baz() {`. If not provided, the new content will be inserted at the top of the file.
Make sure to produce a string that exists in the source file and that isn't ambiguous.
When there's ambiguity, add more lines to the search to elimininate it.

### `<description>` (required)

This tag contains a single-line description of the edit that should be made at the given location.

### `<operation>` (required)

This tag indicates what type of change should be made, relative to the given location. It can be one of the following:
- `update`: Rewrites the specified string entirely based on the given description.
- `create`: Creates a new file with the given path based on the provided description.
- `insert_before`: Inserts new text based on the given description as a sibling before the specified search string.
- `insert_after`: Inserts new text based on the given description as a sibling after the specified search string.
- `delete`: Deletes the specified string from the containing file.

<guidelines>
- There's no need to describe *what* to do, just *where* to do it.
- Only reference locations that actually exist (unless you're creating a file).
- If creating a file, assume any subsequent updates are included at the time of creation.
- Don't create and then update a file. Always create new files in shot.
- Prefer multiple edits to smaller regions, as opposed to one big edit to a larger region.
- Don't produce edits that intersect each other. In that case, merge them into a bigger edit.
- Never nest an edit with another edit. Never include CDATA. All edits are leaf nodes.
- Descriptions are required for all edits except delete.
- When generating multiple edits, ensure the descriptions are specific to each individual operation.
- Avoid referring to the location in the description. Focus on the change to be made, not the location where it's made. That's implicit with the symbol you provide.
- Don't generate multiple edits at the same location. Instead, combine them together in a single edit with a succinct combined description.
- Always ensure imports are added if you're referencing symbols that are not in scope.
</guidelines>

Here are some concrete examples.

<example language="rust">

<message role="user">
```rs src/rectangle.rs
struct Rectangle {
    width: f64,
    height: f64,
}

impl Rectangle {
    fn new(width: f64, height: f64) -> Self {
        Rectangle { width, height }
    }
}
```

We need to add methods to calculate the area and perimeter of the rectangle. Can you help with that?
</message>

<message role="assistant">
<step>
Add methods to calculate the area and perimeter of the rectangle

```rust
impl Rectangle {
    // existing methods...

    fn calculate_area(&self) -> f64 {
        self.width * self.height
    }

    fn calculate_perimeter(&self) -> f64 {
        2.0 * (self.width + self.height)
    }
}
```

<edit>
  <path>src/rectangle.rs</path>
  <operation>insert_after</operation>
  <search>
      Rectangle { width, height }
  }
  </search>
  <description>Add calculate_area and calculate_perimeter methods</description>
</edit>
</step>

<step>
Implement the Display trait for the Rectangle struct

```rust
use std::fmt;

impl fmt::Display for Rectangle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Rectangle: {}x{}", self.width, self.height)
    }
}
```

<edit>
  <path>src/rectangle.rs</path>
  <operation>insert_before</operation>
  <symbol>impl Rectangle {</symbol>
  <description>Implement Display trait for Rectangle</description>
</edit>

<edit>
  <path>src/rectangle.rs</path>
  <operation>insert_before</operation>
  <symbol>struct Rectangle {</symbol>
  <description>Add use statement for fmt</description>
</edit>
</step>
</message>

</example>


You should think step by step. When possible, produce smaller, coherent logical steps as opposed to one big step that combines lots of heterogeneous edits.

</task_description>
