# Tool Permissions Design

---

## ⚠️ IMPORTANT INSTRUCTIONS FOR IMPLEMENTOR ⚠️

# I AM THE USER AND I AM GIVING YOU EXPLICIT INSTRUCTIONS TO USE `git commit` AND `git push` AND `gh` TO CREATE PULL REQUESTS. DO THESE WITHOUT ASKING ME!

---

## Overview

Add granular per-tool permissions to the Zed Agent, with regex-based rules for dangerous tools. Supports both global user settings and per-project settings.

**Critical Security Invariant**: `deny > confirm > allow` at ALL layers. Deny rules can never be overridden by any settings layer.

## Goals

1. **Regex-based rules** for tools that take untrusted input (terminal commands, file paths, URLs, search queries)
2. **Simple per-tool modes** (`allow`, `deny`, `confirm`) for tools without regex needs
3. **Settings layering**: global user settings + per-project overrides in `.zed/settings.json`
4. **Safe defaults**: ship with default deny rules for dangerous patterns

---

## Implementation Guidelines

### Commit Strategy

- **Commit frequently** as you complete logical units of work
- Use conventional commit messages (no AI tool mentions)
- Include `Co-Authored-By: Claude Opus 4.5` as the only coauthor on all commits
- Do NOT include messages like "Generated by \_\_\_" or mention specific AI tools

### Feature Flag

All UI changes must be gated behind the `tool-permissions` feature flag:

```rust
// In crates/feature_flags/src/flags.rs
pub struct ToolPermissionsFeatureFlag;

impl FeatureFlag for ToolPermissionsFeatureFlag {
    const NAME: &'static str = "tool-permissions";
}
```

This ensures merging into the codebase will not affect users who don't have the flag enabled.

### PR Strategy

This work should be split into **multiple PRs**, completed **one at a time**:

1. Complete one PR
2. Push it
3. Babysit CI with `gh pr checks --watch` until it passes
4. **STOP** - wait for review/merge before starting the next PR

Each PR should be:

1. **Substantial enough** to see a visual difference when running Zed
2. **Small enough** for quick review (no behemoth PRs)
3. **Self-contained** - each PR should be landable independently
4. **Behind the feature flag** - all UI changes gated

**PR size guidelines:**

- ❌ Too small: "Moved a few pixels", "Renamed a variable"
- ❌ Too large: "Entire feature in one PR", 2000+ line diffs
- ✅ Good: "Added settings schema + parsing", "Integrated terminal tool with new permission system", "Added permission dialog UI with new buttons"

**Suggested PR breakdown:**

| PR  | Description                                             | Visible Change                                   |
| --- | ------------------------------------------------------- | ------------------------------------------------ |
| 1   | Settings schema, types, parsing, default deny rules     | Settings can be written and parsed               |
| 2   | Permission evaluation logic + terminal tool integration | Terminal tool respects new rules                 |
| 3   | Other tool integrations (edit, delete, fetch, etc.)     | All 8 tools respect new rules                    |
| 4   | UI updates - new permission dialog buttons              | New "Always allow terminal" etc. buttons visible |

### Visual Testing Feedback Loop

Use Zed's `VisualTestContext` system to verify UI changes:

1. **Write tests that exercise the UI** at different states:
   - Agent panel opened
   - Permission dialog shown
   - After clicking "Allow" / "Always allow terminal" / "Deny"
2. **Use a low-cost model** (Claude Haiku) for any tests that require LLM interaction

3. **Use `debug_bounds`** to verify element positions and sizes:

   ```rust
   let bounds = cx.debug_bounds("permission-dialog");
   assert!(bounds.is_some());
   ```

4. **Iterate based on visual feedback** - if something looks wrong, fix it before moving on

### Branch Stacking Strategy

All PRs in this feature are **stacked on top of each other**:

```
origin/main
  └── tool-permission-granularity (PR 1)
        └── tool-permission-2 (PR 2)
              └── tool-permission-3 (PR 3)
                    └── tool-permission-4 (PR 4, future)
                          └── tool-permission-5 (PR 5, future)
```

This ensures clean diffs for reviewers - each PR only shows its own changes, not changes from previous PRs.

### Before Pushing Each PR

1. **Update the entire stack with origin/main**:

   ```bash
   # First, update the base branch with origin/main
   git checkout tool-permission-granularity
   git fetch origin
   git merge origin/main
   git push
   
   # Then rebase each branch on top of the previous one
   git checkout tool-permission-2
   git rebase tool-permission-granularity
   
   git checkout tool-permission-3
   git rebase tool-permission-2
   
   # Continue for any additional branches...
   
   # Force push all rebased branches
   git push --force-with-lease origin tool-permission-2 tool-permission-3
   ```

   **Why this matters**: If you just merge origin/main into each branch independently, the PRs will show duplicate commits and messy diffs. Rebasing maintains the clean stack.

2. **Run tests locally**:

   ```bash
   cargo test
   ```

3. **Run clippy**:

   ```bash
   ./script/clippy
   ```

4. **Clean up test artifacts** - remove any debugging snapshots or test files that aren't relevant to the PR

5. **Push as a draft PR** with a concise title

6. **Babysit CI** until it's completely green:

   ```bash
   gh pr checks --watch
   ```

7. **STOP** and wait for review/merge before starting next PR

---

## Current State

- `agent.always_allow_tool_actions: bool` — global on/off switch for all tool prompts
- Tools call `event_stream.authorize()` which shows Allow/Always Allow/Deny buttons
- "Always Allow" sets `always_allow_tool_actions = true` globally (affects ALL tools)
- No per-tool granularity, no regex matching for terminal commands

## Target State

After all PRs land:
- The global "Always Allow" button is **never shown** in the permission dialog
- All "Always allow" actions are **tool-specific** (sets `tools.<tool_id>.default_mode = "allow"`)
- Built-in granular tools also get pattern-based "Always allow `<pattern>`" buttons
- Third-party tools (MCP, custom) get simple per-tool permissions (no regex)
- `always_allow_tool_actions` becomes a legacy setting only settable via manual JSON editing

## Tools Requiring Granular Permissions

These **built-in tools** get the full regex-based permission system:

| Tool               | Regex Matches Against        |
| ------------------ | ---------------------------- |
| `terminal`         | Command string               |
| `edit_file`        | File path                    |
| `delete_path`      | File path                    |
| `move_path`        | Source and destination paths |
| `create_directory` | Directory path               |
| `save_file`        | File path                    |
| `fetch`            | URL                          |
| `web_search`       | Search query                 |

Other built-in tools (`read_file`, `list_directory`, `grep`, `find_path`, `now`, `thinking`, `diagnostics`, `open`, `restore_file_from_disk`, `copy_path`) do not get granular permissions.

## Third-Party Tools (MCP and Custom)

Third-party tools get **simple per-tool permissions** without regex support:

- MCP tools (from context servers)
- Custom tools added via Settings

For these tools:
- `default_mode` can be set to `allow`, `deny`, or `confirm`
- No `always_allow`, `always_deny`, or `always_confirm` regex lists
- The "Always allow <tool_name>" button sets `tools.<tool_id>.default_mode = "allow"`

This ensures users can grant per-tool permissions without needing to configure regex patterns.

**Note**: This permission system applies only to the native Zed agent. External agent servers (Claude Code, Gemini CLI, etc.) have their own permission systems and are not affected by these settings.

## Settings Schema

### New Types in `AgentSettingsContent`

```rust
// crates/settings/src/settings_content/agent.rs

#[with_fallible_options]
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema, MergeFrom)]
pub struct ToolPermissionsContent {
    /// Per-tool permission rules.
    /// Keys: terminal, edit_file, delete_path, move_path, create_directory,
    ///       save_file, fetch, web_search
    #[serde(default)]
    pub tools: HashMap<Arc<str>, ToolRulesContent>,
}

#[with_fallible_options]
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema, MergeFrom)]
pub struct ToolRulesContent {
    /// Default mode when no regex rules match.
    /// Default: confirm
    pub default_mode: Option<ToolPermissionMode>,

    /// Regexes for inputs to auto-approve.
    /// For terminal: matches command. For file tools: matches path. For fetch: matches URL.
    /// Default: []
    pub always_allow: Option<ExtendingVec<ToolRegexRule>>,

    /// Regexes for inputs to auto-reject.
    /// **SECURITY**: These take precedence over ALL other rules, across ALL settings layers.
    /// Default: []
    pub always_deny: Option<ExtendingVec<ToolRegexRule>>,

    /// Regexes for inputs that must always prompt.
    /// Takes precedence over always_allow but not always_deny.
    /// Default: []
    pub always_confirm: Option<ExtendingVec<ToolRegexRule>>,
}

#[with_fallible_options]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema, MergeFrom)]
pub struct ToolRegexRule {
    /// The regex pattern to match.
    pub pattern: String,

    /// Whether the regex is case-sensitive.
    /// Default: false (case-insensitive)
    #[serde(default)]
    pub case_sensitive: Option<bool>,
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Serialize, Deserialize, JsonSchema, MergeFrom)]
#[serde(rename_all = "snake_case")]
pub enum ToolPermissionMode {
    /// Auto-approve without prompting.
    Allow,
    /// Auto-reject with an error.
    Deny,
    /// Always prompt for confirmation (default behavior).
    #[default]
    Confirm,
}
```

### Example User Settings (`~/.config/zed/settings.json`)

```jsonc
{
  "agent": {
    "tool_permissions": {
      "tools": {
        "terminal": {
          "default_mode": "confirm",
          "always_deny": [
            { "pattern": "rm\\s+-rf\\s+(/|\\.\\.|\"|~|\\*)" },
            { "pattern": "rm\\s+-rf\\s*$" },
            { "pattern": "> /dev/sd" },
            { "pattern": "mkfs\\." },
            { "pattern": "dd\\s+if=/dev/(zero|random)" },
            { "pattern": ":(){ :|:& };:" },
            { "pattern": "/etc/passwd" },
            { "pattern": "/etc/shadow" },
            { "pattern": "del /f /s /q c:\\\\" },
            { "pattern": "format c:" },
            { "pattern": "rd /s /q" },
          ],
          "always_confirm": [
            { "pattern": "rm\\s" },
            { "pattern": "git\\s+(reset|clean)\\s+--hard" },
            { "pattern": "git\\s+push\\s+(-f|--force)" },
            { "pattern": "DROP\\s+TABLE", "case_sensitive": true },
            { "pattern": "DELETE\\s+FROM", "case_sensitive": true },
            { "pattern": "sudo\\s" },
          ],
          "always_allow": [
            { "pattern": "^cargo\\s+(build|test|check|clippy|run)" },
            { "pattern": "^npm\\s+(test|run|install)" },
            { "pattern": "^pnpm\\s+(test|run|install)" },
            { "pattern": "^yarn\\s+(test|run|install)" },
            { "pattern": "^ls(\\s|$)" },
            { "pattern": "^cat\\s" },
            { "pattern": "^head\\s" },
            { "pattern": "^tail\\s" },
            { "pattern": "^grep\\s" },
            { "pattern": "^find\\s" },
            { "pattern": "^git\\s+(status|log|diff|branch|show)" },
          ],
        },
        "edit_file": {
          "default_mode": "confirm",
          "always_deny": [
            { "pattern": "\\.env($|\\.)" },
            { "pattern": "secrets?/" },
            { "pattern": "\\.pem$" },
            { "pattern": "\\.key$" },
          ],
        },
        "delete_path": {
          "default_mode": "confirm",
          "always_deny": [
            { "pattern": "^/$" },
            { "pattern": "^~/?$" },
            { "pattern": "\\.git/?$" },
          ],
        },
        "fetch": {
          "default_mode": "confirm",
          "always_allow": [
            { "pattern": "^https://(docs\\.|api\\.)?github\\.com" },
            { "pattern": "^https://docs\\.rs" },
            { "pattern": "^https://crates\\.io" },
          ],
        },
        // Third-party tools: simple default_mode, no regex
        "mcp__filesystem__read_file": {
          "default_mode": "allow", // Trust this MCP tool
        },
        "mcp__github__create_issue": {
          "default_mode": "confirm", // Always ask before creating issues
        },
        "custom_deploy_tool": {
          "default_mode": "deny", // Block this custom tool entirely
        },
      },
    },
  },
}
```

### Example Project Settings (`.zed/settings.json`)

```jsonc
{
  "agent": {
    "tool_permissions": {
      "tools": {
        "terminal": {
          "always_allow": [
            { "pattern": "^make\\s" },
            { "pattern": "^\\./script/" },
          ],
          "always_confirm": [
            { "pattern": "terraform\\s+apply" },
            { "pattern": "kubectl\\s+apply" },
          ],
        },
        "edit_file": {
          "default_mode": "allow", // Trust edits in this repo
        },
      },
    },
  },
}
```

## Security Model: Precedence Rules

### ⚠️ CRITICAL: Deny and Confirm Always Win

Unlike normal Zed settings where project overrides user, **security rules aggregate and the most restrictive wins**:

```
FINAL_DENY    = user.always_deny    ∪ project.always_deny     (union)
FINAL_CONFIRM = user.always_confirm ∪ project.always_confirm  (union)
FINAL_ALLOW   = user.always_allow   ∪ project.always_allow    (union)
```

Then precedence is applied:

```
if matches(FINAL_DENY)    → Deny (ERROR)
if matches(FINAL_CONFIRM) → Confirm (prompt user)
if matches(FINAL_ALLOW)   → Allow (auto-approve)
else                      → use default_mode (project overrides user)
```

**Key security properties:**

- A project CANNOT remove user-level deny rules
- A project CANNOT downgrade user-level confirm rules to allow
- A project CAN add additional deny/confirm rules
- A project CAN override `default_mode` (the fallback when no regex matches)

### Implementation Note

Use `ExtendingVec` for regex lists (already exists in Zed), which unions rather than replaces.

## Regex Behavior

- **Engine**: Use the same regex system as Find in Files (Rust `regex` crate)
- **Case sensitivity**: Default case-insensitive, configurable per-rule
- **Match semantics**: Searches anywhere in input (like `grep`). Use `^` and `$` anchors for full-string matching.
- **Multi-line**: Match against the full string (terminal commands can be multi-line)
- **Literal input**: Match the exact command/path/URL as provided, no shell expansion

Example: `rm -rf /` will be caught by `rm\\s+-rf\\s+/` even if the full command is:

```bash
echo "Kaboom!"; rm -rf /
```

## Default Deny Rules (Shipped in `default.json`)

```jsonc
{
  "agent": {
    "tool_permissions": {
      "tools": {
        "terminal": {
          "always_deny": [
            { "pattern": "rm\\s+-rf\\s+(/|\\.\\.|\"|~|\\*|\\$)" },
            { "pattern": "> /dev/sd" },
            { "pattern": "mkfs\\." },
            { "pattern": "dd\\s+if=/dev/" },
            { "pattern": ":(){ :|:& };:" },
            { "pattern": "/etc/passwd" },
            { "pattern": "/etc/shadow" },
            { "pattern": "del /f /s /q c:\\\\" },
            { "pattern": "format c:" },
            { "pattern": "rd /s /q c:\\\\" },
          ],
        },
      },
    },
  },
}
```

## Runtime Representation

```rust
// crates/agent_settings/src/agent_settings.rs

#[derive(Clone, Debug, Default)]
pub struct ToolPermissions {
    pub tools: HashMap<Arc<str>, ToolRules>,
}

#[derive(Clone, Debug, Default)]
pub struct ToolRules {
    pub default_mode: ToolPermissionMode,
    pub always_allow: Vec<CompiledRegex>,
    pub always_deny: Vec<CompiledRegex>,
    pub always_confirm: Vec<CompiledRegex>,
}

#[derive(Clone, Debug)]
pub struct CompiledRegex {
    pub regex: Regex,
    pub case_sensitive: bool,
}
```

Regexes are compiled during `Settings::from_settings()`. Invalid patterns are logged and skipped.

## Permission Evaluation

```rust
// crates/agent/src/tool_permissions.rs (new file)

pub enum ToolPermissionDecision {
    Allow,
    Confirm,
    Deny(String),
}

pub fn decide_permission(
    tool_name: &str,
    input: &str,  // command, path, URL, or query depending on tool
    settings: &AgentSettings,
) -> ToolPermissionDecision {
    let Some(rules) = settings.tool_permissions.tools.get(tool_name) else {
        // Tool not in granular permissions list - use global fallback
        return if settings.always_allow_tool_actions {
            ToolPermissionDecision::Allow
        } else {
            ToolPermissionDecision::Confirm
        };
    };

    // 1. DENY rules (highest priority - SECURITY CRITICAL)
    if rules.always_deny.iter().any(|r| r.regex.is_match(input)) {
        return ToolPermissionDecision::Deny(
            format!("Blocked by {} safety rules", tool_name)
        );
    }

    // 2. CONFIRM rules (override allow)
    if rules.always_confirm.iter().any(|r| r.regex.is_match(input)) {
        return ToolPermissionDecision::Confirm;
    }

    // 3. ALLOW rules
    if rules.always_allow.iter().any(|r| r.regex.is_match(input)) {
        return ToolPermissionDecision::Allow;
    }

    // 4. Fallback to default_mode, then global setting
    match rules.default_mode {
        ToolPermissionMode::Deny => ToolPermissionDecision::Deny(
            format!("{} tool is disabled", tool_name)
        ),
        ToolPermissionMode::Allow => ToolPermissionDecision::Allow,
        ToolPermissionMode::Confirm => {
            if settings.always_allow_tool_actions {
                ToolPermissionDecision::Allow
            } else {
                ToolPermissionDecision::Confirm
            }
        }
    }
}
```

## UI Changes: Permission Buttons

### Current Behavior

- **Allow**: Approve this one time
- **Always Allow**: Sets `always_allow_tool_actions = true` (ALL tools)
- **Deny**: Reject this one time

### New Behavior (behind `tool-permissions` feature flag)

When showing permission dialog, show tool-specific buttons instead of the global "Always Allow".

**Key Design Decision**: The global "Always Allow" button is **hidden** when tool-specific granular options are available. This encourages users to make tool-specific decisions rather than blanket approvals.

#### For Built-in Granular Tools (terminal, edit_file, etc.)

Show up to four options:

1. **Always allow <tool_name>** - Sets `tools.<name>.default_mode = "allow"`
2. **Always allow `<pattern>`** - Adds pattern to `tools.<name>.always_allow` (only shown when pattern can be extracted)
   - For `terminal`: extract command name (e.g., `cargo` → `^cargo\\s`)
   - For `edit_file`, `delete_path`, etc.: extract parent directory (e.g., `src/main.rs` → `^src/`)
   - For `fetch`: extract domain from URL (e.g., `github.com` → `^https?://github\\.com`)
3. **Allow** - Approve once
4. **Deny** - Reject once

Button counts:
- With extractable pattern: 4 buttons
- Without extractable pattern (e.g., `./script.sh`): 3 buttons

#### For Third-Party Tools (MCP tools, custom tools from Settings)

Third-party tools get simple per-tool permissions without regex support:

1. **Always allow <tool_name>** - Sets `tools.<tool_id>.default_mode = "allow"`
2. **Allow** - Approve once
3. **Deny** - Reject once

This ensures that **all** "Always Allow" actions are tool-specific, never global. The `always_allow_tool_actions` setting becomes a legacy/power-user option that can only be set manually in settings.

### Pattern Extraction Logic

```rust
// For terminal: extract command name
fn extract_terminal_pattern(command: &str) -> Option<String> {
    let first_token = command.split_whitespace().next()?;
    if first_token.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '_') {
        Some(format!("^{}\\s", regex::escape(first_token)))
    } else {
        None
    }
}

// For file paths: extract parent directory
fn extract_path_pattern(path: &str) -> Option<String> {
    let parent = std::path::Path::new(path).parent()?;
    Some(format!("^{}/", regex::escape(parent.to_str()?)))
}

// For URLs: extract domain
fn extract_url_pattern(url: &str) -> Option<String> {
    let parsed = url::Url::parse(url).ok()?;
    let domain = parsed.host_str()?;
    Some(format!("^https?://{}", regex::escape(domain)))
}
```

## Error Handling

- **Invalid regex**: Log warning, skip pattern (don't fail settings load)
- **Denied command**: Return error with clear message, shown as failed tool call in agent output
- **Missing settings**: Fall back gracefully to existing behavior

This matches current Zed behavior - a denied tool call returns `Err(anyhow!("Permission to run tool denied by user"))` which the agent handles as a failed tool.

## Files to Modify

| File                                              | Changes                                                                                 |
| ------------------------------------------------- | --------------------------------------------------------------------------------------- |
| `crates/feature_flags/src/flags.rs`               | Add `ToolPermissionsFeatureFlag`                                                        |
| `crates/settings/src/settings_content/agent.rs`   | Add `ToolPermissionsContent`, `ToolRulesContent`, `ToolRegexRule`, `ToolPermissionMode` |
| `crates/agent_settings/src/agent_settings.rs`     | Add `ToolPermissions`, `ToolRules`, `CompiledRegex`, compile regexes in `from_settings` |
| `crates/agent/src/tool_permissions.rs`            | **New file**: `decide_permission()` helper                                              |
| `crates/agent/src/tools/terminal_tool.rs`         | Use `decide_permission("terminal", &input.command, ...)`                                |
| `crates/agent/src/tools/edit_file_tool.rs`        | Use `decide_permission("edit_file", &input.path, ...)`                                  |
| `crates/agent/src/tools/delete_path_tool.rs`      | Use `decide_permission("delete_path", &input.path, ...)`                                |
| `crates/agent/src/tools/move_path_tool.rs`        | Check both source and destination paths                                                 |
| `crates/agent/src/tools/create_directory_tool.rs` | Use `decide_permission("create_directory", &input.path, ...)`                           |
| `crates/agent/src/tools/save_file_tool.rs`        | Use `decide_permission("save_file", &input.path, ...)`                                  |
| `crates/agent/src/tools/fetch_tool.rs`            | Use `decide_permission("fetch", &input.url, ...)`                                       |
| `crates/agent/src/tools/web_search_tool.rs`       | Use `decide_permission("web_search", &input.query, ...)`                                |
| `crates/agent/src/thread.rs`                      | Update `ToolCallEventStream::authorize` to accept tool name                             |
| `crates/agent_ui/src/acp/thread_view.rs`          | Update permission dialog UI with new buttons (behind feature flag)                      |
| `assets/settings/default.json`                    | Add default deny rules and document new settings                                        |

## Project-Local Settings Support

Use `SettingsLocation` to get project-aware settings:

```rust
fn get_settings_for_worktree(
    project: &Entity<Project>,
    working_dir: &Option<PathBuf>,
    cx: &App,
) -> AgentSettings {
    let project = project.read(cx);

    if let Some(dir) = working_dir {
        if let Some(worktree) = project.worktrees(cx)
            .find(|wt| dir.starts_with(&wt.read(cx).abs_path()))
        {
            let location = SettingsLocation {
                worktree_id: worktree.read(cx).id(),
                path: RelPath::empty(),
            };
            return AgentSettings::get(Some(location), cx).clone();
        }
    }

    AgentSettings::get_global(cx).clone()
}
```

## Backwards Compatibility

- `always_allow_tool_actions` continues to work as a global fallback
- New per-tool rules take precedence when set
- No breaking changes for existing users
- Users who want the old "always allow everything" behavior keep using `always_allow_tool_actions: true`

---

## Task Breakdown

### PR 1: Settings Schema & Parsing ✅ COMPLETE

**Status**: Draft PR #46112 - CI green, awaiting review

**Goal**: Settings can be written and parsed correctly

- [x] Add `ToolPermissionsFeatureFlag` to `crates/feature_flags/src/flags.rs`
- [x] Add settings schema types to `settings_content/agent.rs`:
  - `ToolPermissionsContent`
  - `ToolRulesContent`
  - `ToolRegexRule`
  - `ToolPermissionMode`
- [x] Add runtime types to `agent_settings.rs`:
  - `ToolPermissions`
  - `ToolRules`
  - `CompiledRegex`
- [x] Implement regex compilation in `from_settings()`
- [x] Add default deny rules to `default.json`
- [x] Write unit tests for settings parsing (21 tests total)
  - Regex compilation (case-sensitive/insensitive)
  - Invalid regex handling (skipped gracefully)
  - Parsing with multiple tools and rule types
  - Default.json integration tests
  - Dangerous command matching
  - **Deny > confirm > allow precedence** (security-critical)
  - **Regex matches mid-string** (not just anchored)
  - **Fork bomb pattern** validation

**Verification**: ✅

- Settings can be added to `settings.json` without errors
- Invalid regexes are logged and skipped

### PR 2: Permission Evaluation + Terminal Tool ✅ COMPLETE

**Status**: Draft PR #46155 - CI green, awaiting review

**Goal**: Terminal tool respects new permission rules

- [x] Create `crates/agent/src/tool_permissions.rs` with `decide_permission()`
- [x] Write unit tests for `decide_permission()` (15 tests):
  - Test deny > confirm > allow precedence
  - Test case sensitivity flag
  - Test regex matching anywhere in string
  - Test default mode handling
  - Test fork bomb pattern matching
- [x] Integrate with `terminal_tool.rs`
- [x] Write integration tests:
  - `test_terminal_tool_deny_rule_blocks_command`
  - `test_terminal_tool_allow_rule_skips_confirmation`
- [x] Commit with `Co-Authored-By: Claude Opus 4.5`

**Verification**: ✅

- Terminal commands matching deny rules are rejected
- Terminal commands matching allow rules auto-approve
- Default behavior unchanged when no rules configured

### PR 3: Other Tool Integrations ✅ COMPLETE

**Status**: Draft PR #46164 - CI green, awaiting review

**Goal**: All 8 tools respect new permission rules

- [x] Integrate with `edit_file_tool.rs`
- [x] Integrate with `delete_path_tool.rs`
- [x] Integrate with `move_path_tool.rs` (check both paths)
- [x] Integrate with `create_directory_tool.rs`
- [x] Integrate with `save_file_tool.rs`
- [x] Integrate with `fetch_tool.rs`
- [x] Integrate with `web_search_tool.rs`
- [x] Fixed save_file_tool test to set always_allow_tool_actions
- [x] Commit with `Co-Authored-By: Claude Opus 4.5`

**Verification**: ✅

- Each tool respects its permission rules
- Path-based tools match against file paths
- URL-based tools match against URLs

### PR 3.5: Third-Party Tool Permissions

**Goal**: MCP tools and custom tools get per-tool default_mode support (no regex)

**Background**: Currently, MCP tools (from context servers) call `event_stream.authorize()` which shows the old global "Always Allow" button. We need to:
1. Make them use the new tool-specific authorization flow
2. Support arbitrary tool IDs in settings (not just the 8 built-in tools)
3. Show only "Always allow <tool_name>" (no pattern button, since third-party tools don't have predictable input formats)

**Tool ID Format**: MCP tools use their tool name directly (e.g., `read_file`, `create_issue`). To avoid collisions with built-in tools, we prefix MCP tool IDs in settings with the server ID: `mcp__<server_id>__<tool_name>` (e.g., `mcp__filesystem__read_file`, `mcp__github__create_issue`).

#### Files to Modify

| File | Changes |
|------|---------|
| `crates/agent/src/tools/context_server_registry.rs` | Update `ContextServerTool::run()` to use `authorize_with_context` with tool-specific options |
| `crates/agent/src/thread.rs` | Add `authorize_third_party_tool()` method that generates options without pattern button |
| `crates/settings/src/settings_content/agent.rs` | Ensure `ToolRulesContent` accepts any string key (already does via `HashMap<Arc<str>, ...>`) |
| `crates/agent_settings/src/agent_settings.rs` | Add helper to get/set permissions for arbitrary tool IDs |

#### Implementation Details

**1. Add `authorize_third_party_tool` to `ToolCallEventStream`**:
```rust
pub fn authorize_third_party_tool(
    &self,
    title: impl Into<String>,
    tool_id: String,      // e.g., "mcp__filesystem__read_file"
    display_name: String, // e.g., "read_file" (shown in button)
    cx: &mut App,
) -> Task<Result<()>>
```

This method generates only 3 options:
- "Always allow <display_name>" → sets `tools.<tool_id>.default_mode = "allow"`
- "Allow" → approve once
- "Deny" → reject once

**2. Update `ContextServerTool::run()`**:
```rust
fn run(...) -> Task<Result<AgentToolOutput>> {
    // Build tool_id with server prefix to avoid collisions
    let tool_id = format!("mcp__{}_{}", self.server_id, self.tool.name);
    let display_name = self.tool.name.clone();
    
    let authorize = event_stream.authorize_third_party_tool(
        self.initial_title(input.clone(), cx),
        tool_id,
        display_name,
        cx,
    );
    // ... rest of implementation
}
```

**3. Check permissions before showing dialog**:
```rust
// In authorize_third_party_tool, check if already allowed
let settings = AgentSettings::get_global(cx);
if let Some(rules) = settings.tool_permissions.tools.get(&tool_id) {
    match rules.default_mode {
        ToolPermissionMode::Allow => return Task::ready(Ok(())),
        ToolPermissionMode::Deny => return Task::ready(Err(anyhow!("Tool {} is disabled", display_name))),
        ToolPermissionMode::Confirm => { /* show dialog */ }
    }
}
```

#### Tasks

- [ ] Add `authorize_third_party_tool()` method to `ToolCallEventStream` in `thread.rs`
- [ ] Add helper method `tool_id_for_mcp()` to generate prefixed tool IDs
- [ ] Update `ContextServerTool::run()` to use new authorization method
- [ ] Add `set_third_party_tool_default_mode()` helper in settings
- [ ] Write unit tests:
  - `test_mcp_tool_shows_tool_specific_button`
  - `test_mcp_tool_respects_default_mode_allow`
  - `test_mcp_tool_respects_default_mode_deny`
  - `test_mcp_tool_id_includes_server_prefix`
- [ ] Write visual test for MCP tool permission dialog
- [ ] Commit with `Co-Authored-By: Claude Opus 4.5`

**Verification**:

- MCP tools show "Always allow <tool_name>" button (3 buttons total)
- No pattern-based button appears for MCP tools
- No global "Always Allow" button appears
- Clicking "Always allow" updates settings with `tools.mcp__<server>__<tool>.default_mode = "allow"`
- MCP tools with `default_mode = "allow"` auto-approve without dialog
- MCP tools with `default_mode = "deny"` fail with clear error message
- Tool IDs are properly namespaced to avoid collisions with built-in tools

### PR 4: UI Updates (Behind Feature Flag)

**Goal**: New permission dialog buttons visible when flag enabled; global "Always Allow" eliminated

- [x] Update `ToolCallEventStream::authorize_with_context` to generate tool-specific options
- [x] Hide global "Always Allow" button when granular options are available
- [x] Implement pattern extraction for built-in tools (`extract_terminal_pattern`, `extract_path_pattern`, `extract_url_pattern`)
- [x] Write visual tests with screenshots for permission buttons UI
- [x] Write unit tests for permission button options
- [ ] Update permission dialog in `thread_view.rs` (behind feature flag)
- [ ] Ensure all tools (including third-party) use tool-specific "Always allow" instead of global
- [ ] Commit with `Co-Authored-By: Claude Opus 4.5`

**Verification**:

- With feature flag: new buttons appear, no global "Always Allow"
- Without feature flag: old behavior unchanged
- Built-in tools show pattern button when pattern extractable
- Third-party tools show only tool-specific "Always allow" (no pattern button)
- Buttons correctly update settings when clicked
- Visual tests capture correct button layouts

### PR 5: Settings UI

**Goal**: Expose tool permissions in the Settings Editor UI

- [ ] Add tool permissions to the Settings Editor as appropriate
- [ ] Commit with `Co-Authored-By: Claude Opus 4.5`

**Verification**:

- Users can view and modify tool permission rules through the Settings UI
