use collections::HashMap;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::{
    error::Error,
    fmt::{Display, Write},
    sync::LazyLock,
};

use super::KeyCode;

/// A keystroke and associated metadata generated by the platform
#[derive(Clone, Debug, Eq, PartialEq, Default, Hash)]
pub struct Keystroke {
    /// the state of the modifier keys at the time the keystroke was generated
    pub modifiers: Modifiers,

    /// TODO:
    pub code: KeyCode,

    /// key is the character printed on the key that was pressed
    /// e.g. for option-s, key is "s"
    pub face: String,

    /// key_char is the character that could have been typed when
    /// this binding was pressed.
    /// e.g. for s this is "s", for option-s "ß", and cmd-s None
    pub key_char: Option<String>,
}

/// Error type for `Keystroke::parse`. This is used instead of `anyhow::Error` so that Zed can use
/// markdown to display it.
#[derive(Debug)]
pub struct InvalidKeystrokeError {
    /// The invalid keystroke.
    pub keystroke: String,
}

impl Error for InvalidKeystrokeError {}

impl Display for InvalidKeystrokeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Invalid keystroke \"{}\". {}",
            self.keystroke, KEYSTROKE_PARSE_EXPECTED_MESSAGE
        )
    }
}

/// Sentence explaining what keystroke parser expects, starting with "Expected ..."
pub const KEYSTROKE_PARSE_EXPECTED_MESSAGE: &str = "Expected a sequence of modifiers \
    (`ctrl`, `alt`, `shift`, `fn`, `cmd`, `super`, or `win`) \
    followed by a key, separated by `-`.";

impl Keystroke {
    /// When matching a key we cannot know whether the user intended to type
    /// the key_char or the key itself. On some non-US keyboards keys we use in our
    /// bindings are behind option (for example `$` is typed `alt-ç` on a Czech keyboard),
    /// and on some keyboards the IME handler converts a sequence of keys into a
    /// specific character (for example `"` is typed as `" space` on a brazilian keyboard).
    ///
    /// This method assumes that `self` was typed and `target' is in the keymap, and checks
    /// both possibilities for self against the target.
    pub(crate) fn should_match(&self, target: &Keystroke) -> bool {
        // if let Some(key_char) = self
        //     .key_char
        //     .as_ref()
        //     .filter(|key_char| key_char != &&self.key)
        // {
        //     let ime_modifiers = Modifiers {
        //         control: self.modifiers.control,
        //         platform: self.modifiers.platform,
        //         ..Default::default()
        //     };

        //     if &target.key == key_char && target.modifiers == ime_modifiers {
        //         return true;
        //     }
        // }

        // target.modifiers == self.modifiers && target.key == self.key
        let key_comparison = if self.code == KeyCode::Unknown {
            target.code == KeyCode::Unknown && self.face == target.face
        } else {
            self.code == target.code
        };
        key_comparison && self.modifiers == target.modifiers
    }

    /// key syntax is:
    /// [secondary-][ctrl-][alt-][shift-][cmd-][fn-]key[->key_char]
    /// key_char syntax is only used for generating test events,
    /// secondary means "cmd" on macOS and "ctrl" on other platforms
    /// when matching a key with an key_char set will be matched without it.
    pub fn parse(
        source: &str,
        char_matching: bool,
        key_equivalents: Option<&HashMap<char, char>>,
    ) -> std::result::Result<Self, InvalidKeystrokeError> {
        let mut control = false;
        let mut alt = false;
        let mut shift = false;
        let mut platform = false;
        let mut function = false;
        let mut key = None;
        let mut key_char = None;

        let mut components = source.split('-').peekable();
        while let Some(component) = components.next() {
            if component.eq_ignore_ascii_case("ctrl") {
                control = true;
                continue;
            }
            if component.eq_ignore_ascii_case("alt") {
                alt = true;
                continue;
            }
            if component.eq_ignore_ascii_case("shift") {
                shift = true;
                continue;
            }
            if component.eq_ignore_ascii_case("fn") {
                function = true;
                continue;
            }
            if component.eq_ignore_ascii_case("secondary") {
                if cfg!(target_os = "macos") {
                    platform = true;
                } else {
                    control = true;
                };
                continue;
            }

            let is_platform = component.eq_ignore_ascii_case("cmd")
                || component.eq_ignore_ascii_case("super")
                || component.eq_ignore_ascii_case("win");

            if is_platform {
                platform = true;
                continue;
            }

            let mut key_str = component.to_string();

            if let Some(next) = components.peek() {
                if next.is_empty() && source.ends_with('-') {
                    key = Some(String::from("-"));
                    break;
                } else if next.len() > 1 && next.starts_with('>') {
                    key = Some(key_str);
                    key_char = Some(String::from(&next[1..]));
                    components.next();
                } else {
                    return Err(InvalidKeystrokeError {
                        keystroke: source.to_owned(),
                    });
                }
                continue;
            }

            if component.len() == 1 && component.as_bytes()[0].is_ascii_uppercase() {
                // Convert to shift + lowercase char
                shift = true;
                key_str.make_ascii_lowercase();
            } else {
                // convert ascii chars to lowercase so that named keys like "tab" and "enter"
                // are accepted case insensitively and stored how we expect so they are matched properly
                key_str.make_ascii_lowercase()
            }
            key = Some(key_str);
        }

        // Allow for the user to specify a keystroke modifier as the key itself
        // This sets the `key` to the modifier, and disables the modifier
        if key.is_none() {
            if shift {
                key = Some("shift".to_string());
                shift = false;
            } else if control {
                key = Some("control".to_string());
                control = false;
            } else if alt {
                key = Some("alt".to_string());
                alt = false;
            } else if platform {
                key = Some("platform".to_string());
                platform = false;
            } else if function {
                key = Some("function".to_string());
                function = false;
            }
        }

        let key = key.ok_or_else(|| InvalidKeystrokeError {
            keystroke: source.to_owned(),
        })?;
        let mut code = KeyCode::parse(&key).unwrap_or_default();
        if code == KeyCode::Unknown {
            if let Some((key_code, modifier)) = CHAR_TO_KEY.get(&key) {
                code = *key_code;
                if modifier.shift {
                    if shift {
                        log::error!("Key {} has both shift and alt modifiers", key);
                    }
                    shift = true;
                    println!("shift");
                }
                if modifier.alt {
                    if alt {
                        log::error!("Key {} has both alt and shift modifiers", key);
                    }
                    alt = true;
                    println!("alt");
                }
                println!("Key {} -> {:?}", source, key_code);
            }
        }

        let ret = Ok(Keystroke {
            modifiers: Modifiers {
                control,
                alt,
                shift,
                platform,
                function,
            },
            code,
            face: key,
            key_char,
        });
        if code == KeyCode::Unknown {
            println!("parse key stroke: {}, {:#?}", source, ret);
        }
        ret
    }

    /// Produces a representation of this key that Parse can understand.
    pub fn unparse(&self) -> String {
        let mut str = String::new();
        if self.modifiers.function {
            str.push_str("fn-");
        }
        if self.modifiers.control {
            str.push_str("ctrl-");
        }
        if self.modifiers.alt {
            str.push_str("alt-");
        }
        if self.modifiers.platform {
            #[cfg(target_os = "macos")]
            str.push_str("cmd-");

            #[cfg(any(target_os = "linux", target_os = "freebsd"))]
            str.push_str("super-");

            #[cfg(target_os = "windows")]
            str.push_str("win-");
        }
        if self.modifiers.shift {
            str.push_str("shift-");
        }
        str.push_str(&self.face);
        str
    }

    /// Returns true if this keystroke left
    /// the ime system in an incomplete state.
    pub fn is_ime_in_progress(&self) -> bool {
        self.key_char.is_none()
            && (self.code.is_printable() || (self.code == KeyCode::Unknown && self.face.is_empty()))
            && !(self.modifiers.platform
                || self.modifiers.control
                || self.modifiers.function
                || self.modifiers.alt)
    }

    /// Returns a new keystroke with the key_char filled.
    /// This is used for dispatch_keystroke where we want users to
    /// be able to simulate typing "space", etc.
    pub fn with_simulated_ime(mut self) -> Self {
        if self.key_char.is_none()
            && !self.modifiers.platform
            && !self.modifiers.control
            && !self.modifiers.function
            && !self.modifiers.alt
        {
            self.key_char = match self.code {
                KeyCode::Space => Some(" ".into()),
                KeyCode::Tab => Some("\t".into()),
                KeyCode::Enter => Some("\n".into()),
                key if !key.is_printable() || (key == KeyCode::Unknown && self.face == "") => None,
                _ => {
                    if self.modifiers.shift {
                        Some(self.face.to_uppercase())
                    } else {
                        Some(self.face.clone())
                    }
                }
            }
        }
        self
    }
}

fn is_printable_key(key: &str) -> bool {
    !matches!(
        key,
        "f1" | "f2"
            | "f3"
            | "f4"
            | "f5"
            | "f6"
            | "f7"
            | "f8"
            | "f9"
            | "f10"
            | "f11"
            | "f12"
            | "f13"
            | "f14"
            | "f15"
            | "f16"
            | "f17"
            | "f18"
            | "f19"
            | "f20"
            | "f21"
            | "f22"
            | "f23"
            | "f24"
            | "f25"
            | "f26"
            | "f27"
            | "f28"
            | "f29"
            | "f30"
            | "f31"
            | "f32"
            | "f33"
            | "f34"
            | "f35"
            | "backspace"
            | "delete"
            | "left"
            | "right"
            | "up"
            | "down"
            | "pageup"
            | "pagedown"
            | "insert"
            | "home"
            | "end"
            | "back"
            | "forward"
            | "escape"
    )
}

impl std::fmt::Display for Keystroke {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.modifiers.control {
            f.write_char('^')?;
        }
        if self.modifiers.alt {
            f.write_char('⌥')?;
        }
        if self.modifiers.platform {
            #[cfg(target_os = "macos")]
            f.write_char('⌘')?;

            #[cfg(any(target_os = "linux", target_os = "freebsd"))]
            f.write_char('❖')?;

            #[cfg(target_os = "windows")]
            f.write_char('⊞')?;
        }
        if self.modifiers.shift {
            f.write_char('⇧')?;
        }
        let key = match self.face.as_str() {
            "backspace" => '⌫',
            "up" => '↑',
            "down" => '↓',
            "left" => '←',
            "right" => '→',
            "tab" => '⇥',
            "escape" => '⎋',
            "shift" => '⇧',
            "control" => '⌃',
            "alt" => '⌥',
            "platform" => '⌘',
            key => {
                if key.len() == 1 {
                    key.chars().next().unwrap().to_ascii_uppercase()
                } else {
                    return f.write_str(key);
                }
            }
        };
        f.write_char(key)
    }
}

/// The state of the modifier keys at some point in time
#[derive(Copy, Clone, Debug, Eq, PartialEq, Default, Serialize, Deserialize, Hash, JsonSchema)]
pub struct Modifiers {
    /// The control key
    #[serde(default)]
    pub control: bool,

    /// The alt key
    /// Sometimes also known as the 'meta' key
    #[serde(default)]
    pub alt: bool,

    /// The shift key
    #[serde(default)]
    pub shift: bool,

    /// The command key, on macos
    /// the windows key, on windows
    /// the super key, on linux
    #[serde(default)]
    pub platform: bool,

    /// The function key
    #[serde(default)]
    pub function: bool,
}

impl Modifiers {
    /// Returns whether any modifier key is pressed.
    pub fn modified(&self) -> bool {
        self.control || self.alt || self.shift || self.platform || self.function
    }

    /// Whether the semantically 'secondary' modifier key is pressed.
    ///
    /// On macOS, this is the command key.
    /// On Linux and Windows, this is the control key.
    pub fn secondary(&self) -> bool {
        #[cfg(target_os = "macos")]
        {
            self.platform
        }

        #[cfg(not(target_os = "macos"))]
        {
            self.control
        }
    }

    /// Returns how many modifier keys are pressed.
    pub fn number_of_modifiers(&self) -> u8 {
        self.control as u8
            + self.alt as u8
            + self.shift as u8
            + self.platform as u8
            + self.function as u8
    }

    /// Returns [`Modifiers`] with no modifiers.
    pub fn none() -> Modifiers {
        Default::default()
    }

    /// Returns [`Modifiers`] with just the command key.
    pub fn command() -> Modifiers {
        Modifiers {
            platform: true,
            ..Default::default()
        }
    }

    /// A Returns [`Modifiers`] with just the secondary key pressed.
    pub fn secondary_key() -> Modifiers {
        #[cfg(target_os = "macos")]
        {
            Modifiers {
                platform: true,
                ..Default::default()
            }
        }

        #[cfg(not(target_os = "macos"))]
        {
            Modifiers {
                control: true,
                ..Default::default()
            }
        }
    }

    /// Returns [`Modifiers`] with just the windows key.
    pub fn windows() -> Modifiers {
        Modifiers {
            platform: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with just the super key.
    pub fn super_key() -> Modifiers {
        Modifiers {
            platform: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with just control.
    pub fn control() -> Modifiers {
        Modifiers {
            control: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with just alt.
    pub fn alt() -> Modifiers {
        Modifiers {
            alt: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with just shift.
    pub fn shift() -> Modifiers {
        Modifiers {
            shift: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with command + shift.
    pub fn command_shift() -> Modifiers {
        Modifiers {
            shift: true,
            platform: true,
            ..Default::default()
        }
    }

    /// Returns [`Modifiers`] with command + shift.
    pub fn control_shift() -> Modifiers {
        Modifiers {
            shift: true,
            control: true,
            ..Default::default()
        }
    }

    /// Checks if this [`Modifiers`] is a subset of another [`Modifiers`].
    pub fn is_subset_of(&self, other: &Modifiers) -> bool {
        (other.control || !self.control)
            && (other.alt || !self.alt)
            && (other.shift || !self.shift)
            && (other.platform || !self.platform)
            && (other.function || !self.function)
    }
}

static CHAR_TO_KEY: LazyLock<HashMap<String, (KeyCode, Modifiers)>> = LazyLock::new(|| {
    let mut map = HashMap::default();

    // 0x001d => KeyCode::Digital0,
    let chars = generate_keymap_info(0x001d);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital0, modifiers));
    }
    // 0x0012 => KeyCode::Digital1,
    let chars = generate_keymap_info(0x0012);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital1, modifiers));
    }
    // 0x0013 => KeyCode::Digital2,
    let chars = generate_keymap_info(0x0013);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital2, modifiers));
    }
    // 0x0014 => KeyCode::Digital3,
    let chars = generate_keymap_info(0x0014);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital3, modifiers));
    }
    // 0x0015 => KeyCode::Digital4,
    let chars = generate_keymap_info(0x0015);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital4, modifiers));
    }
    // 0x0017 => KeyCode::Digital5,
    let chars = generate_keymap_info(0x0017);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital5, modifiers));
    }
    // 0x0016 => KeyCode::Digital6,
    let chars = generate_keymap_info(0x0016);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital6, modifiers));
    }
    // 0x001a => KeyCode::Digital7,
    let chars = generate_keymap_info(0x001a);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital7, modifiers));
    }
    // 0x001c => KeyCode::Digital8,
    let chars = generate_keymap_info(0x001c);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital8, modifiers));
    }
    // 0x0019 => KeyCode::Digital9,
    let chars = generate_keymap_info(0x0019);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Digital9, modifiers));
    }
    // 0x0029 => KeyCode::Semicolon,
    let chars = generate_keymap_info(0x0029);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Semicolon, modifiers));
    }
    // 0x0018 => KeyCode::Plus,
    let chars = generate_keymap_info(0x0018);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Plus, modifiers));
    }
    // 0x002b => KeyCode::Comma,
    let chars = generate_keymap_info(0x002b);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Comma, modifiers));
    }
    // 0x001b => KeyCode::Minus,
    let chars = generate_keymap_info(0x001b);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Minus, modifiers));
    }
    // 0x002f => KeyCode::Period,
    let chars = generate_keymap_info(0x002f);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Period, modifiers));
    }
    // 0x002c => KeyCode::Slash,
    let chars = generate_keymap_info(0x002c);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Slash, modifiers));
    }
    // 0x0032 => KeyCode::Tilde,
    let chars = generate_keymap_info(0x0032);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Tilde, modifiers));
    }
    // 0x0021 => KeyCode::LeftBracket,
    let chars = generate_keymap_info(0x0021);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::LeftBracket, modifiers));
    }
    // 0x002a => KeyCode::Backslash,
    let chars = generate_keymap_info(0x002a);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Backslash, modifiers));
    }
    // 0x001e => KeyCode::RightBracket,
    let chars = generate_keymap_info(0x001e);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::RightBracket, modifiers));
    }
    // 0x0027 => KeyCode::Quote,
    let chars = generate_keymap_info(0x0027);
    for (c, modifiers) in chars {
        map.insert(c, (KeyCode::Quote, modifiers));
    }
    // 0x0000 => KeyCode::A,
    // 0x000b => KeyCode::B,
    // 0x0008 => KeyCode::C,
    // 0x0002 => KeyCode::D,
    // 0x000e => KeyCode::E,
    // 0x0003 => KeyCode::F,
    // 0x0005 => KeyCode::G,
    // 0x0004 => KeyCode::H,
    // 0x0022 => KeyCode::I,
    // 0x0026 => KeyCode::J,
    // 0x0028 => KeyCode::K,
    // 0x0025 => KeyCode::L,
    // 0x002e => KeyCode::M,
    // 0x002d => KeyCode::N,
    // 0x001f => KeyCode::O,
    // 0x0023 => KeyCode::P,
    // 0x000c => KeyCode::Q,
    // 0x000f => KeyCode::R,
    // 0x0001 => KeyCode::S,
    // 0x0011 => KeyCode::T,
    // 0x0020 => KeyCode::U,
    // 0x0009 => KeyCode::V,
    // 0x000d => KeyCode::W,
    // 0x0007 => KeyCode::X,
    // 0x0010 => KeyCode::Y,
    // 0x0006 => KeyCode::Z,
    map
});

use crate::chars_for_modified_key;

fn generate_keymap_info(scan_code: u16) -> Vec<(String, Modifiers)> {
    let mut keymap = Vec::new();
    let no_mod = chars_for_modified_key(scan_code, NO_MOD);
    if !no_mod.is_empty() {
        keymap.push((no_mod, Modifiers::none()));
    }
    let shift_mod = chars_for_modified_key(scan_code, SHIFT_MOD);
    if !shift_mod.is_empty() {
        keymap.push((shift_mod, Modifiers::shift()));
    }
    let alt_mod = chars_for_modified_key(scan_code, OPTION_MOD);
    if !alt_mod.is_empty() {
        keymap.push((alt_mod, Modifiers::alt()));
    }
    let shift_alt_mod = chars_for_modified_key(scan_code, SHIFT_MOD | OPTION_MOD);
    if !shift_alt_mod.is_empty() {
        keymap.push((
            shift_alt_mod,
            Modifiers {
                shift: true,
                alt: true,
                ..Default::default()
            },
        ));
    }
    keymap
}

const NO_MOD: u32 = 0;
const CMD_MOD: u32 = 1;
const SHIFT_MOD: u32 = 2;
const OPTION_MOD: u32 = 8;

// pub fn chars_for_modified_key(code: CGKeyCode, modifiers: u32) -> String {
//     // Values from: https://github.com/phracker/MacOSX-SDKs/blob/master/MacOSX10.6.sdk/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers/Events.h#L126
//     // shifted >> 8 for UCKeyTranslate
//     const CG_SPACE_KEY: u16 = 49;
//     // https://github.com/phracker/MacOSX-SDKs/blob/master/MacOSX10.6.sdk/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/CarbonCore.framework/Versions/A/Headers/UnicodeUtilities.h#L278
//     #[allow(non_upper_case_globals)]
//     const kUCKeyActionDown: u16 = 0;
//     #[allow(non_upper_case_globals)]
//     const kUCKeyTranslateNoDeadKeysMask: u32 = 0;

//     let keyboard_type = unsafe { LMGetKbdType() as u32 };
//     const BUFFER_SIZE: usize = 4;
//     let mut dead_key_state = 0;
//     let mut buffer: [u16; BUFFER_SIZE] = [0; BUFFER_SIZE];
//     let mut buffer_size: usize = 0;

//     let keyboard = unsafe { TISCopyCurrentKeyboardLayoutInputSource() };
//     if keyboard.is_null() {
//         return "".to_string();
//     }
//     let layout_data = unsafe {
//         TISGetInputSourceProperty(keyboard, kTISPropertyUnicodeKeyLayoutData as *const c_void)
//             as CFDataRef
//     };
//     if layout_data.is_null() {
//         unsafe {
//             let _: () = msg_send![keyboard, release];
//         }
//         return "".to_string();
//     }
//     let keyboard_layout = unsafe { CFDataGetBytePtr(layout_data) };

//     unsafe {
//         UCKeyTranslate(
//             keyboard_layout as *const c_void,
//             code,
//             kUCKeyActionDown,
//             modifiers,
//             keyboard_type,
//             kUCKeyTranslateNoDeadKeysMask,
//             &mut dead_key_state,
//             BUFFER_SIZE,
//             &mut buffer_size as *mut usize,
//             &mut buffer as *mut u16,
//         );
//         if dead_key_state != 0 {
//             UCKeyTranslate(
//                 keyboard_layout as *const c_void,
//                 CG_SPACE_KEY,
//                 kUCKeyActionDown,
//                 modifiers,
//                 keyboard_type,
//                 kUCKeyTranslateNoDeadKeysMask,
//                 &mut dead_key_state,
//                 BUFFER_SIZE,
//                 &mut buffer_size as *mut usize,
//                 &mut buffer as *mut u16,
//             );
//         }
//         let _: () = msg_send![keyboard, release];
//     }
//     String::from_utf16(&buffer[..buffer_size]).unwrap_or_default()
// }
