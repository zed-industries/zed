use assistant_tooling::{SavedToolFunctionCall, SavedUserAttachment};
use gpui::SharedString;
use serde::{Deserialize, Serialize};

use crate::MessageId;

#[derive(Serialize, Deserialize)]
pub struct SavedConversation {
    /// The schema version of the conversation.
    pub version: String,
    /// The title of the conversation, generated by the Assistant.
    pub title: String,
    pub messages: Vec<SavedChatMessage>,
}

#[derive(Serialize, Deserialize)]
pub enum SavedChatMessage {
    User {
        id: MessageId,
        body: String,
        attachments: Vec<SavedUserAttachment>,
    },
    Assistant {
        id: MessageId,
        messages: Vec<SavedAssistantMessagePart>,
        error: Option<SharedString>,
    },
}

#[derive(Serialize, Deserialize)]
pub struct SavedAssistantMessagePart {
    pub body: SharedString,
    pub tool_calls: Vec<SavedToolFunctionCall>,
}

/// Returns a list of placeholder conversations for mocking the UI.
///
/// Once we have real saved conversations to pull from we can use those instead.
pub fn placeholder_conversations() -> Vec<SavedConversation> {
    vec![
        SavedConversation {
            version: "0.3.0".to_string(),
            title: "How to get a list of exported functions in an Erlang module".to_string(),
            messages: vec![],
        },
        SavedConversation {
            version: "0.3.0".to_string(),
            title: "7 wonders of the ancient world".to_string(),
            messages: vec![],
        },
        SavedConversation {
            version: "0.3.0".to_string(),
            title: "Size difference between u8 and a reference to u8 in Rust".to_string(),
            messages: vec![],
        },
    ]
}
